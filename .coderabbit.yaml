language: "en-US" # USA English
# Set up means coderabbit should review PRs but only provide one high level walkthrough, collapsed
# It should not state preliminary information like: getting ready to review, draw a picture
# It should not state additional information like: related issues, PRs, suggest reviewers
# It should not continue a casual conversation with users that reply to it

# Only documents non-default options:
reviews:
  profile: "assertive" # Assertive profile yields more feedback, that may be considered nitpicky.
  high_level_summary: false # Do not summarise a pull request first as there is a walkthrough
  review_status: false # Do not state what kind of review as performed or why (spammy)
  commit_status: false # Do not state the review is in progress (spammy)
  collapse_walkthrough: true # Provide a walkthrough for reviewers, but collapse it (users shouldn't use this)
  related_issues: false # Do not suggest related issues (spammy)
  related_prs: false # Do not suggest related PRs (spammy)
  suggested_labels: false # Do not suggest labels for the PR (spammy)
  suggested_reviewers: false # Do not suggest reviewers for the PR (spammy)
  in_progress_fortune: false # Do not stall time with a message (spammy)
  poem: false # Do not write a literal poem (spammy)
  enable_prompt_for_ai_agents: false # Disable prompts for AI agents (spammy)

  path_instructions:
    # --- CUSTOM INSTRUCTIONS FOR EXAMPLES DIRECTORY ---
    - path: "examples/**/*"
      instructions: |
        You are acting as a senior maintainer reviewing SDK examples. Your goal is to ensure examples work verbatim for users who copy-paste them.

        **Priority 1 - Correctness**: 
        - Verify transaction lifecycle chain (construction -> freeze_with -> sign -> execute).
        - Ensure `freeze_with(client)` is called BEFORE signing.
        - Validate that methods referenced actually exist in the `hiero_sdk_python` codebase.
        - Ensure response validation checks `receipt.status` against `ResponseCode` enums (e.g., `ResponseCode.SUCCESS`).

        **Priority 2 - Transaction Lifecycle**: 
        - Check method chaining logic.
        - Verify correct signing order (especially for multi-sig).
        - Ensure explicit `.execute(client)` calls.
        - Verify response property extraction (e.g., using `.token_id`, `.account_id`, `.serial_numbers`).
        - Ensure error handling uses `ResponseCode(receipt.status).name` for clarity.

        **Priority 3 - Naming & Clarity**: 
        - Enforce role-based naming: `operator_id`/`_key`, `treasury_account_id`/`_key`, `receiver_id`/`_key`.
        - Use `_id` suffix for AccountId and `_key` suffix for PrivateKey variables.
        - Validate negative examples explicitly check for failure codes (e.g., `TOKEN_HAS_NO_PAUSE_KEY`).
        - Ensure logical top-to-bottom flow without ambiguity.

        **Priority 4 - Consistency**: 
        - Verify standard patterns: `def main()`, `if __name__ == "__main__":`, `load_dotenv()`.
        - **IMPORT RULES**: 
          1. Accept both top-level imports (e.g., `from hiero_sdk_python import PrivateKey`) and fully qualified imports (e.g., `from hiero_sdk_python.crypto.private_key import PrivateKey`).
          2. STRICTLY validate that the import path actually exists in the project structure. Compare against other files in `/examples` or your knowledge of the SDK file tree.
          3. Flag hallucinations immediately (e.g., `hiero_sdk_python.keys` does not exist).
        - Check for `try-except` blocks with `sys.exit(1)` for critical failures.

        **Priority 5 - User Experience**: 
        - Ensure comments explain SDK usage patterns (for users, not contributors).
        - Avoid nitpicking functional code.
        - Suggest type hints or docstrings only if they significantly improve clarity.

        **Philosophy**: 
        - Examples are copied by users - prioritize explicitness over brevity.
        - Avoid suggestions that `ruff` or linters would catch.
        - Be concise, technical, and opinionated.
        - Flag out-of-scope improvements as potential new issues rather than blocking.

    # --- UNIT TESTS REVIEW INSTRUCTIONS ---
    - path: "tests/unit/**/*"
      instructions: |
        You are acting as a senior maintainer reviewing unit tests for the hiero-sdk-python project.  Your goal is to ensure tests are extensive, deterministic, and protect against breaking changes.

        **CRITICAL PRINCIPLES - Tests Must Fail Loudly & Deterministically**:
        - Tests must provide useful error messages when they fail for future debugging.
        - No `print()` statements - use assertions with descriptive messages.
        - No timing-dependent or unseeded random assertions.
        - No network calls or external dependencies (unit tests are isolated).
        - No unjustified TODOs or skipped tests without tracking issues.

        **PRIORITY 1 - Protect Against Breaking Changes**:
        - Assert public attributes exist (e.g., `assert hasattr(obj, 'account_id')`).
        - Assert return types where relevant (e.g., `assert isinstance(result, AccountId)`).
        - Assert fluent setters return `self` (e.g., `assert tx.set_memo("test") is tx`).
        - Assert backward-compatible defaults are maintained. 
        - If a breaking change is introduced, tests must assert deprecation behavior and test old behavior until removal.

        **PRIORITY 2 - Constructor & Setter Behavior**:
        - Test constructor behavior with valid inputs, edge cases, and invalid inputs.
        - Test setter behavior including method chaining (fluent interface).
        - Verify that setters validate input and raise appropriate exceptions.
        - Test that getters return expected values after construction/setting.

        **PRIORITY 3 - Comprehensive Coverage**: 
        - Unit tests should be extensive - test even if we don't expect users to use it currently.
        - Cover happy paths AND unhappy paths/edge cases.
        - Test boundary conditions, null/None values, empty collections, etc.
        - Avoid brittle ordering assertions unless order is part of the contract. 

        **PRIORITY 4 - No Mocks for Non-Existent Modules**:
        - All imports must reference actual SDK modules - no hallucinated paths.
        - Validate import paths against the actual `src/hiero_sdk_python` structure.
        - Mocks should only be used for external dependencies, not SDK internals.

        **PRIORITY 5 - Test Framework Philosophy**:
        - Prefer repetitive but clear tests over abstracted helper functions.
        - Some core functionality may warrant helper files (considered an exception).
        - Discourage custom helper functions; prefer pytest fixtures when shared setup is needed. 
        - Prefer testing real functionality over mocked behavior.

        **AVOID**:
        - Linter or formatting feedback (leave that to ruff/pre-commit).
        - Nitpicking minor stylistic issues unless they impact maintainability.
        - Overly abstracted test helpers that obscure what's being tested. 

        **PHILOSOPHY**:  
        - Unit tests protect our future selves - be defensive and forward-looking.
        - Tests should be readable by SDK developers:  clear names, brief docstrings, key inline comments.
        - When tests fail, we should immediately know what broke and why.

    # --- INTEGRATION TESTS REVIEW INSTRUCTIONS ---
    - path: "tests/integration/**/*"
      instructions: |
        You are acting as a senior maintainer reviewing integration tests for the hiero-sdk-python project. Your goal is to ensure end-to-end tests validate real network behavior safely and deterministically.

        **CRITICAL PRINCIPLES - Safety & Diagnosability**:
        - **Prioritize safety**: No implicit or default mainnet usage.
        - Secrets and credentials must be injected safely (env vars, not hardcoded).
        - Test failures must be diagnosable with clear error messages.
        - Tests must assert observable network behavior, not just `SUCCESS`.
        - Failure-path tests must assert specific `ResponseCode` values (e.g., `TOKEN_HAS_NO_PAUSE_KEY`).

        **PRIORITY 1 - End-to-End Behavior**:
        - Tests should be end-to-end:  construct → freeze → sign → execute → verify.
        - Validate resulting balances, ownership, and state changes (not just transaction success).
        - Assert transaction receipts contain expected data (IDs, serial numbers, etc.).
        - Verify network state after operations (e.g., account balance changed, token transferred).

        **PRIORITY 2 - Test Structure & Maintainability**:
        - One major behavior per test (clear focus).
        - Tests should be readable:  clear names, brief docstrings, key inline comments.
        - Minimal abstraction layers - prefer clarity over DRY.
        - Is the file too monolithic? Flag if tests should be split into smaller modules. 
        - Are helper functions good candidates for pytest fixtures or shared utilities?

        **PRIORITY 3 - Isolation & Cleanup**:
        - Local account creation over operator reuse (avoid state pollution).
        - Are accounts, tokens, and allowances properly cleaned up to avoid state leakage?
        - Recommend teardown strategies or fixture scoping improvements. 
        - Tests should not depend on execution order (avoid brittle assumptions).

        **PRIORITY 4 - Assertions & Coverage**:
        - Do tests validate only success/failure, or also assert resulting state? 
        - Suggest additional assertions that would strengthen correctness (balances, allowances, ownership).
        - Cover happy paths AND unhappy paths (e.g., invalid spender, revoked allowance, insufficient balance).
        - Avoid timing-based or flaky assumptions.

        **PRIORITY 5 - Observability & Debugging**:
        - Could structured logging or transaction metadata improve debugging?
        - Suggest capturing allowance values, transaction IDs, and balances in logs.
        - Ensure error messages provide context for failure diagnosis. 

        **AVOID**:
        - Linter or formatting feedback.
        - Overly abstracted helpers that obscure what's being tested.
        - Timing-dependent assertions (use explicit waits or retries if needed).

        **PHILOSOPHY**: 
        - Integration tests validate real network behavior - they must be reliable and safe.
        - Tests should protect against regressions while being maintainable.
        - When tests fail in CI, developers should immediately understand what broke. 
        - Redundant setup code should be refactored, but clarity trumps abstraction.

    # --- DOCUMENTATION REVIEW INSTRUCTIONS ---
    - path: "docs/**"
      instructions: |
        You are reviewing documentation for the Hiero Python SDK. These pages serve both SDK users and SDK developers.

        Priority 1 - Correctness (code, commands, links, facts)
        1. Verify code snippets conceptually run and match the current SDK API, patterns, and file layout.
        2. Check shell commands, config examples, and workflow steps against the actual project tooling and CI setup.
        3. Validate URLs and cross-references where possible; flag clearly broken or misleading links.
        4. For external links, ensure they remain relevant and don't introduce version mismatches with our SDK.
        5. Flag references to deprecated SDK patterns without noting the modern alternative.

        Priority 2 - Clarity and comprehensibility
        1. Ensure each page states its purpose and expected outcome early.
        2. Prefer concrete, step-wise explanations over vague descriptions.
        3. Highlight missing pre-requisites or hidden assumptions that would block a reader.

        Priority 3 - Completeness and usefulness
        1. Identify critical gaps that prevent a reader from completing the described task.
        2. For larger missing sections or conceptual overviews, suggest filing a follow-up issue instead of blocking the PR.
        3. Encourage adding minimal examples or links when they would unlock understanding.

        Priority 4 - Consistency with existing docs
        1. Encourage consistent terminology with the SDK, examples, and tests (e.g. operator, client, network, transaction lifecycle).
        2. Suggest aligning naming and structure with existing docs when inconsistencies could confuse readers.
        3. Avoid bikeshedding tone or style when meaning is already clear.

        Priority 5 - Accessibility and navigation
        1. Check headings and sections form a logical reading path.
        2. Encourage scannable sections, short paragraphs, and descriptive headings where it materially aids navigation.

        Audience alignment
        - Confirm each page makes clear which audience it serves (SDK user, SDK developer, or both) and stays focused on their goals.
        - Flag mixed guidance that lacks transitions or pointers to the audience-specific sections.
        - For pages serving both audiences, suggest clear signposts (e.g., "if you're an SDK user, skip to X; if you're a developer, continue here").

        PHILOSOPHY
        - Treat documentation as work-in-progress: optimize for correctness and clarity over perfection.
        - Prefer incremental improvements and follow-up issues for bigger restructures or training gaps.
        - Keep feedback concise, action-oriented, and focused on what most improves reader success.

        CRITICAL PRINCIPLES
        - Flag incorrect or outdated code, commands, or links.
        - Flag steps that cannot be followed successfully as written.
        - Do not request large-scale restructures unless current structure actively blocks understanding.

        AVOID
        - Avoid lint-style feedback on Markdown formatting or minor wording when meaning is already clear.
        - Avoid proposing new conventions without clear benefit or alignment with existing docs.
        - Avoid turning every high-level gap into a blocker; prefer suggesting an issue instead.

    - path: "docs/sdk_users/**"
      instructions: |
        These documents are for SDK users who want to USE the Hiero Python SDK quickly and correctly, not learn internals or project workflow.

        Priority 1 - Code snippet correctness and completeness
        1. Ensure examples are copy-pasteable and complete enough to run (imports, client/operator setup, core logic).
        2. Verify import paths and APIs follow current patterns, e.g. `from hiero_sdk_python... import ...`, and agree with `examples/`.
        3. Encourage minimal, realistic error handling where it prevents user confusion, without overwhelming the reader.
        4. Highlight platform-specific gotchas (Windows vs POSIX, Python version constraints, virtual environment steps) that could block users.

        Priority 2 - Step-by-step clarity
        1. Check that instructions form an explicit, ordered sequence from setup to successful result.
        2. Flag vague phrases (e.g. "just configure X") and suggest concrete, actionable steps or links.
        3. Ensure required environment variables, keys, and network choices are clearly stated or linked.
        4. Verify prerequisites (e.g., `NETWORK`, operator credentials, .env defaults) align with our current quick-start guidance.
        5. Highlight edge cases that could cause confusion or errors, such as handling multiple accounts or tokens.

        Priority 3 - No hidden assumptions about SDK knowledge
        1. Assume zero prior knowledge of this SDK and minimal Hedera background.
        2. Avoid requiring knowledge of repository layout, tests, or contribution workflow.
        3. Encourage brief explanations of key concepts only as needed to complete the task.

        Priority 4 - Actionable, unambiguous instructions
        1. Prefer specific commands, parameters, and expected outputs over high-level advice.
        2. Flag ambiguous wording that could lead to multiple interpretations or errors.
        3. Suggest adding small clarifications instead of large rewrites when only a step or sentence is missing.

        Priority 5 - Real-world applicability
        1. Encourage examples that reflect realistic use cases (transfers, tokens, contracts), not only trivial snippets.
        2. Suggest cross-linking to `examples/` where it directly helps the user achieve a goal.

        PHILOSOPHY
        - Time-to-first-success is the main metric: make it easy for a new user to send a working transaction.
        - Keep explanations concrete, self-contained, and immediately actionable.
        - Prefer small, focused improvements that make the happy path smoother.

        CRITICAL PRINCIPLES
        - Do not assume any knowledge of how the SDK is implemented or how this repo is structured.
        - Flag incomplete examples (missing imports, initialization, or essential parameters).
        - Ensure examples match the current API and example patterns in this repository.

        AVOID
        - Avoid introducing contribution, CI, or workflow details; link to developer docs instead if truly needed.
        - Avoid overloading user-facing docs with deep architectural discussion.
        - Avoid suggesting structural changes that do not materially improve the user's ability to complete tasks.

    - path: "docs/sdk_developers/**"
      instructions: |
        These documents are for SDK developers and contributors, including `docs/sdk_developers/training/**`. Assume mixed experience: some readers are new to the codebase, others are experienced.

        Priority 1 - Accuracy of workflows and commands
        1. Ensure contribution, branching, rebasing, signing (DCO, GPG), CI, linting, and testing instructions match the actual repo configuration.
        2. Verify `git` and GitHub flows agree with CONTRIBUTING.md and current project practice.
        3. Flag outdated references to scripts, make targets, directories, or configuration files.
        4. Ensure automation references (assignment guards, dry-run toggles, required permissions) match the latest workflow behavior.

        Priority 2 - Coverage of edge cases and gotchas
        1. Encourage documentation of common pitfalls (merge conflicts, flaky tests, environment issues) when they affect contributors often.
        2. Suggest referencing real examples (PRs, tests, workflows) when they clarify tricky behavior.
        3. Keep warnings concrete and actionable rather than generic.

        Priority 3 - Alignment with codebase conventions
        1. Check terminology, naming, and patterns (e.g. transaction lifecycle, Executable usage, retry logic) against the actual code.
        2. Encourage examples that reflect how the SDK is structured and tested today.
        3. Flag inconsistencies between docs, examples, and tests that could mislead contributors.

        Priority 4 - Progressive learning flow (especially training/)
        1. For training docs, ensure a logical progression from setup → small change → tests → advanced topics.
        2. Check that numbering, cross-links, and prerequisites between training files are coherent.
        3. Highlight gaps where a new contributor would not know what to do next.
        4. Encourage explicit "next steps" or pointers to subsequent modules when a lesson ends.
        5. For each training module, confirm whether it can stand alone or silently assumes knowledge from earlier modules.

        Priority 5 - References to source code and examples
        1. Encourage deep links to relevant modules, tests, and examples when they serve as canonical patterns.
        2. Ensure file paths and symbol names referenced in docs actually exist and are up-to-date.

        PHILOSOPHY
        - Treat these docs as a training ground for future maintainers and regular contributors.
        - Help readers move from “I cloned the repo” to “I can safely extend and debug the SDK”.
        - Balance approachability for beginners with enough depth for experts looking for specific architectural details.

        CRITICAL PRINCIPLES
        - Verify that all workflow and tooling instructions reflect the current CI, linting, testing, and release practices.
        - Flag inaccurate references to internal architecture or modules (e.g. Executable, transaction pipeline, retry behavior).
        - Ensure training materials are not misleading or internally contradictory.

        AVOID
        - Avoid demanding large structural rewrites of the training program in a single PR; prefer suggesting follow-up issues.
        - Avoid generic documentation advice that does not consider this repository's actual patterns.
        - Avoid blocking changes for minor stylistic issues when the technical guidance is sound.

    # --- CUSTOM INSTRUCTIONS FOR .GITHUB DIRECTORY ---
    - path: ".github/workflows/**/*"
      instructions: |
        Review workflows as security-sensitive infrastructure.

        A good workflow is small, focused, and boring.
        If a workflow is clever, generic, or overly flexible, it is a risk.

        ---------------------------------------------------------
        PRIORITY 0 — ABSOLUTE REQUIREMENTS 
        ---------------------------------------------------------
        - All third-party actions MUST be pinned to full commit SHAs, similar to other workflows.
        - `permissions:` MUST be explicitly declared and minimally scoped.
        - Workflows MUST behave safely when executed from forks.
        - YAML MUST orchestrate steps, not implement business logic.
        - Any workflow that mutates GitHub state MUST support dry-run mode.
        - Dry-run behavior must be explicit and visible in logs.
        - Workflows MUST NOT modify repository source code outside `.github/`.

        ---------------------------------------------------------
        PRIORITY 1 — SCOPE, FOCUS & RESTRAINT
        ---------------------------------------------------------
        - The title of each workflow must be relevant, match similar naming schemes, and match its script filename.
        - Each workflow MUST have a single, clearly defined objective and SHOULD document this in a top-level comment.
        - Flag workflows that:
          - Attempt to be generic “frameworks”
          - Include speculative or future-facing logic
          - Perform actions unrelated to the stated goal
        - Over-abstraction and excess flexibility are maintenance risks.

        ---------------------------------------------------------
        PRIORITY 2 — INPUT HARDENING
        ---------------------------------------------------------
        - Treat ALL GitHub event data as potentially hostile input, including:
          - issue titles, bodies, and comments
          - labels, usernames, branch names
        - Free-form user input MUST NOT be passed directly into:
          - shell commands
          - gh CLI arguments
          - Node.js exec / spawn calls
        - Require strict allowlists or exact string matches.
        - Flag any use of:
          - eval or bash -c
          - backticks or $(...) with user-controlled input

        ---------------------------------------------------------
        PRIORITY 3 — DRY-RUN & SAFE OPERATION
        ---------------------------------------------------------
        - Workflows that mutate state MUST expose:
          workflow_dispatch:
            inputs:
              dry_run:
                default: "true"
        - When dry_run=true, workflows MUST:
          - Log dry mode is active
          - Function on dry run: never post, comment, label, assign or edit
          - Be easy to expand in the future
          - Exit successfully

        ---------------------------------------------------------
        PRIORITY 4 — SCRIPT EXTRACTION & CODE TRIM
        ---------------------------------------------------------
        - YAML should orchestrate execution only.
        - All non-trivial logic MUST live in:
          - `.github/scripts/*.sh`
          - `.github/scripts/*.js`
        - Workflow filenames and their primary scripts SHOULD share a clear, matching name.
        - Scripts MUST remain:
          - Purpose-built
          - Trim and readable
          - Easy to maintain
        - Flag:
          - Large `run: |` blocks
          - Inline loops, conditionals, or API calls in YAML
          - Overly generic helper scripts for narrow tasks

        ---------------------------------------------------------
        PRIORITY 5 — API EFFICIENCY & DISCIPLINE
        ---------------------------------------------------------
        - GitHub API usage must be intentional and minimal.
        - Prefer:
          - Aggregated queries over per-entity loops
          - Server-side filtering over client-side iteration
          - Reusing data already present in the event payload
        - Pagination MUST:
          - Be considered and justified
          - Enforce hard upper bounds
        - Flag:
          - Repeated API calls inside loops
          - Unbounded pagination
          - Fetching data already available in context

        ---------------------------------------------------------
        PRIORITY 6 — CONCURRENCY & IDEMPOTENCY
        ---------------------------------------------------------
        - Workflows that mutate state MUST:
          - Define a deterministic concurrency group
          - Be safe under retries and parallel execution
        - Duplicate prevention is REQUIRED:
          - Marker-based comment detection
          - Check-before-create logic for labels and assignments
        - Assume workflows may:
          - Run multiple times
          - Be retried automatically
          - Execute concurrently with other automations
        - Workflows should avoid logic that duplicates or causes conflicts.

        ---------------------------------------------------------
        PRIORITY 7 — PERMISSION CORRECTNESS
        ---------------------------------------------------------
        - Requested permissions MUST exactly match behavior.
        - Explicitly validate common cases:
          - issues: write → comments, labels, assignments
          - contents: read → repository checkout
          - pull-requests: write → PR mutations
        - Flag:
          - Over-permissioned workflows
          - Under-permissioned workflows that would fail at runtime
          - Reliance on default permissions

        ---------------------------------------------------------
        PRIORITY 8 — LOGGING & OPERABILITY
        ---------------------------------------------------------
        - Logs should include, where applicable:
          - repository
          - workflow name
          - issue or PR number
          - triggering actor
          - dry-run status
          - decisions made (performed vs skipped)
        - Avoid:
          - Silent success or silent skips
          - Raw payload dumps
          - Any secret or token leakage

    # ============================================================
    # SHELL SCRIPTS
    # ============================================================
    - path: ".github/scripts/**/*.sh"
      instructions: |
        Treat shell scripts as production-grade automation.

        Scripts should be small, focused, and explicit.
        Avoid “do-everything” or overly generic scripts.

        - MUST use: `set -euo pipefail`
        - MUST validate all required environment variables
        - MUST defensively quote variables
        - MUST validate all untrusted input
        - MUST have bounded loops and pagination
        - MUST support dry-run mode if state is mutated
        - MUST log key decisions and early exits

    # ============================================================
    # JAVASCRIPT SCRIPTS
    # ============================================================
    - path: ".github/scripts/**/*.js"
      instructions: |
        Review JavaScript scripts as long-lived automation code.

        Scripts must remain:
        - Focused
        - Readable
        - Purpose-built

        - All `context.payload` fields MUST be validated
        - Free-form text MUST NOT be trusted
        - Dynamic code execution is prohibited
        - Avoid `child_process.exec`; prefer `execFile` if needed
        - All async operations MUST be wrapped in try/catch
        - Errors MUST include contextual metadata
        - Duplicate API calls MUST be avoided
        - Marker-based deduplication is required
        - Scripts MUST NOT assume write access
        - Permission failures MUST be handled gracefully

chat:
  art: false # Don't draw ASCII art (false)
  auto_reply: false # Don't allow bot to converse (spammy)
