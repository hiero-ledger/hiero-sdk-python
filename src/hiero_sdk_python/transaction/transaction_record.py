"""
This module implements the TransactionRecord class which represents a complete record
of a transaction executed on the Hiero network. It serves as a comprehensive data
structure that captures all aspects of a transaction's execution and its effects.

The module provides functionality to:
- Store and access detailed transaction metadata (ID, hash, memo, fees)
- Track various types of asset transfers:
  * HBAR cryptocurrency transfers between accounts
  * Fungible token transfers with amounts
  * Non-fungible token (NFT) transfers with serial numbers
- Handle smart contract execution results
- Process airdrop records for token distributions
- Manage pseudo-random number generation (PRNG) outputs
- Convert between Hiero's internal representation and protobuf messages

"""

from collections import defaultdict
from dataclasses import dataclass, field
from typing import Optional

from hiero_sdk_python.account.account_id import AccountId
from hiero_sdk_python.contract.contract_function_result import ContractFunctionResult
from hiero_sdk_python.hapi.services import transaction_record_pb2
from hiero_sdk_python.tokens.token_airdrop_pending_record import PendingAirdropRecord
from hiero_sdk_python.tokens.token_id import TokenId
from hiero_sdk_python.tokens.token_nft_transfer import TokenNftTransfer
from hiero_sdk_python.transaction.transaction_id import TransactionId
from hiero_sdk_python.transaction.transaction_receipt import TransactionReceipt


@dataclass
class TransactionRecord:
    """
    Represents a record of a completed transaction on the Hiero network.
    This class combines detailed information about the a transaction including the
    transaction ID, receipt, token and NFT transfers, fees & other
    metadata such as pseudo-random number generation(PRNG) results and 
    pending airdrop records.

    Attributes:
        transaction_id (Optional[TransactionId]):         The unique identifier of the transaction.
        transaction_hash (Optional[bytes]):               The raw hash of the transaction as recorded on-chain.
        transaction_memo (Optional[str]):                 A text memo associated with the transaction.
        transaction_fee (Optional[int]):                  The total network fee (in tinybars) charged for the transaction.
        receipt (Optional[TransactionReceipt]):           The receipt summarizing the outcome and status of the transaction.
        call_result (Optional[ContractFunctionResult]):   The result of a contract call if the transaction was a smart contract execution.
        token_transfers (defaultdict[TokenId, defaultdict[AccountId, int]]): 
                                                          A mapping of token IDs to account-level transfer amounts. 
                                                          Represents fungible token movements within the transaction.                                        
        nft_transfers (defaultdict[TokenId, list[TokenNftTransfer]]): 
                                                          A mapping of token IDs to lists of NFT transfers for that token.
        transfers (defaultdict[AccountId, int]):          A mapping of account IDs to hbar transfer amounts (positive for credit, negative for debit).
        new_pending_airdrops (list[PendingAirdropRecord]):A list of new airdrop records created by this transaction.
            
        prng_number (Optional[int]):                      A pseudo-random integer generated by the network (if applicable).
        prng_bytes (Optional[bytes]):                     A pseudo-random byte array generated by the network (if applicable).
        duplicates (list[TransactionRecord]):             A list of duplicate transaction records returned when queried
                                                          with include_duplicates=True. Empty by default.
    """

    transaction_id: Optional[TransactionId] = None
    transaction_hash: Optional[bytes] = None
    transaction_memo: Optional[str] = None
    transaction_fee: Optional[int] = None
    receipt: Optional[TransactionReceipt] = None
    call_result: Optional[ContractFunctionResult] = None

    token_transfers: defaultdict[TokenId, defaultdict[AccountId, int]] = field(default_factory=lambda: defaultdict(lambda: defaultdict(int)))
    nft_transfers: defaultdict[TokenId, list[TokenNftTransfer]] = field(default_factory=lambda: defaultdict(list[TokenNftTransfer]))
    transfers: defaultdict[AccountId, int] = field(default_factory=lambda: defaultdict(int))
    new_pending_airdrops: list[PendingAirdropRecord] = field(default_factory=list)

    prng_number: Optional[int] = None
    prng_bytes: Optional[bytes] = None
    duplicates: list['TransactionRecord'] = field(default_factory=list)

    def __repr__(self) -> str:
        """Returns a human-readable string representation of the TransactionRecord.
        
        This method constructs a detailed string containing all significant fields of the 
        transaction record including transaction ID, hash, memo, fees, status, transfers,
        and PRNG results. For the receipt status, it attempts to resolve the numeric status
        to a human-readable ResponseCode name.
        
        Returns:
            str: A string representation showing all significant fields of the TransactionRecord.
        """
        status = None
        if self.receipt:
            try:
                from hiero_sdk_python.response_code import ResponseCode

                status = ResponseCode(self.receipt.status).name
            except (ValueError, AttributeError):
                status = self.receipt.status
        return (f"TransactionRecord(transaction_id='{self.transaction_id}', "
                f"transaction_hash={self.transaction_hash}, "
                f"transaction_memo='{self.transaction_memo}', "
                f"transaction_fee={self.transaction_fee}, "
                f"receipt_status='{status}', "
                f"token_transfers={dict(self.token_transfers)}, "
                f"nft_transfers={dict(self.nft_transfers)}, "
                f"transfers={dict(self.transfers)}, "
                f"new_pending_airdrops={list(self.new_pending_airdrops)}, "
                f"call_result={self.call_result}, "
                f"prng_number={self.prng_number}, "
                f"prng_bytes={self.prng_bytes}, "
                f"duplicates_count={len(self.duplicates)})")

    @classmethod
    def _from_proto(
        cls,
        proto: transaction_record_pb2.TransactionRecord,
        transaction_id: Optional[TransactionId] = None,
        duplicates: Optional[list['TransactionRecord']] = None,
    ) -> 'TransactionRecord':
        """Creates a TransactionRecord instance from a protobuf transaction record.

        This method performs complex data aggregation from the protobuf message,
        including:
        - Basic transaction metadata (hash, memo, fees)
        - Token transfers (both fungible and non-fungible)
        - Account balance transfers
        - Contract execution results
        - Airdrop records
        - PRNG (pseudo-random number generation) results
        The method maps all nested transfer data from the raw protobuf message into
        the structured format used by the TransactionRecord class & organizing them

        into appropriate defaultdict collections for efficient access.

        Args:
            proto: The raw protobuf transaction record containing all transaction data.
            transaction_id: The transaction ID to associate with this record (required).
            duplicates: Optional list of duplicate transaction records to attach.
                        Defaults to an empty list.

        Returns:
            TransactionRecord: A new instance containing all processed and structured data.
        """
        tx_id = cls._resolve_transaction_id(proto, transaction_id)
        duplicates = duplicates or []

        token_transfers, nft_transfers = cls._parse_token_transfers(proto)
        transfers = cls._parse_hbar_transfers(proto)
        new_pending_airdrops = cls._parse_pending_airdrops(proto)
        call_result = cls._parse_contract_call_result(proto)

        return cls(
            transaction_id=tx_id,
            transaction_hash=proto.transactionHash,
            transaction_memo=proto.memo,
            transaction_fee=proto.transactionFee,
            receipt=TransactionReceipt._from_proto(proto.receipt, tx_id),
            token_transfers=token_transfers,
            nft_transfers=nft_transfers,
            transfers=transfers,
            new_pending_airdrops=new_pending_airdrops,
            call_result=call_result,
            prng_number=proto.prng_number,
            prng_bytes=proto.prng_bytes,
            duplicates=duplicates,
        )

    @staticmethod
    def _resolve_transaction_id(
        proto: transaction_record_pb2.TransactionRecord,
        transaction_id: Optional[TransactionId],
    ) -> TransactionId:
        """Resolves the transaction ID from proto or raises error if not available."""
        if proto.HasField("transactionID"):
            return TransactionId._from_proto(proto.transactionID)
    
        if transaction_id is not None:
            return transaction_id
    
        raise ValueError("transaction_id is required when proto.transactionID is not present")

    @staticmethod
    def _parse_token_transfers(
        proto: transaction_record_pb2.TransactionRecord,
    ) -> tuple[dict, dict]:
        """Parses fungible and non-fungible token transfers from proto."""
        token_transfers = defaultdict(lambda: defaultdict(int))
        nft_transfers = defaultdict(list)

        for ttl in proto.tokenTransferLists:
            token_id = TokenId._from_proto(ttl.token)

            # Fungible token transfers
            for transfer in ttl.transfers:
                account_id = AccountId._from_proto(transfer.accountID)
                token_transfers[token_id][account_id] = transfer.amount

            # Non-fungible (NFT) transfers
            nft_transfers[token_id].extend(
                TokenNftTransfer._from_proto(ttl)
            )

        return token_transfers, nft_transfers

    @staticmethod
    def _parse_hbar_transfers(
        proto: transaction_record_pb2.TransactionRecord,
    ) -> dict:
        """Parses HBAR transfers from proto."""
        transfers = defaultdict(int)
        for transfer in proto.transferList.accountAmounts:
            account_id = AccountId._from_proto(transfer.accountID)
            transfers[account_id] += transfer.amount
        return transfers

    @staticmethod
    def _parse_pending_airdrops(
        proto: transaction_record_pb2.TransactionRecord,
    ) -> list:
        """Parses pending airdrop records from proto."""
        return [
            PendingAirdropRecord._from_proto(pending)
            for pending in proto.new_pending_airdrops
        ]

    @staticmethod
    def _parse_contract_call_result(
        proto: transaction_record_pb2.TransactionRecord,
    ) -> Optional[ContractFunctionResult]:
        """Parses contract call result from proto if present."""
        if proto.HasField("contractCallResult"):
            return ContractFunctionResult._from_proto(proto.contractCallResult)
        return None

    def _to_proto(self) -> transaction_record_pb2.TransactionRecord:
        """Converts the TransactionRecord instance to its protobuf representation.

        Note: The 'duplicates' field is intentionally **not** serialized.
        Duplicate records are only present in query responses and are never
        included when sending TransactionRecord messages to the network.
        
        This method serializes all components of the transaction record into a protobuf message,
        including:
        - Basic transaction metadata (hash, memo, fees)
        - Token transfers (both fungible and non-fungible)
        - Account balance transfers
        - Contract execution results
        - Airdrop records
        - PRNG (pseudo-random number generation) results

        The method performs a deep conversion of all nested objects (token transfers,
        NFT transfers, account transfers, and pending airdrops) to their respective
        protobuf representations.

        Returns:
            transaction_record_pb2.TransactionRecord: A protobuf message containing
            all the transaction record data in a format suitable for network transmission
            or storage.
        """
        record_proto = transaction_record_pb2.TransactionRecord(
            transactionHash=self.transaction_hash,
            memo=self.transaction_memo,
            transactionFee=self.transaction_fee,
            receipt=self.receipt._to_proto() if self.receipt else None,
            contractCallResult=(
                self.call_result._to_proto() if self.call_result else None
            ),
            prng_number=self.prng_number,
            prng_bytes=self.prng_bytes,
        )

        if self.transaction_id is not None:
            record_proto.transactionID.CopyFrom(self.transaction_id._to_proto())

        for token_id, account_transfers in self.token_transfers.items():
            token_transfer_list = record_proto.tokenTransferLists.add()
            token_transfer_list.token.CopyFrom(token_id._to_proto())
            for account_id, amount in account_transfers.items():
                transfer = token_transfer_list.transfers.add()
                transfer.accountID.CopyFrom(account_id._to_proto())
                transfer.amount = amount

        for token_id, nft_transfers in self.nft_transfers.items():
            token_transfer_list = record_proto.tokenTransferLists.add()
            token_transfer_list.token.CopyFrom(token_id._to_proto())
            for nft_transfer in nft_transfers:
                token_transfer_list.nftTransfers.append(nft_transfer._to_proto())

        for account_id, amount in self.transfers.items():
            transfer = record_proto.transferList.accountAmounts.add()
            transfer.accountID.CopyFrom(account_id._to_proto())
            transfer.amount = amount

        for pending_airdrop in self.new_pending_airdrops:
            record_proto.new_pending_airdrops.add().CopyFrom(pending_airdrop._to_proto())

        return record_proto
    